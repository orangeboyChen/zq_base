## 迭代器模式
**顺序访问集合对象的元素，不需要知道集合对象的底层表示。**
通过把在元素之间游走的责任交给迭代器，而不是聚合对象来实现
## 模板模式
**一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行**
不同子类中的一些方法都是通用的，但是每一个子类都进行重写，即模板
## 策略模式
**一个类的行为或其算法可以在运行时更改**
实现同一个接口后，通过将不同的算法封装成一个一个的类从而进行任意的替换。
## 责任链模式
**为请求创建一个接收者对象的链，给予请求的类型，对请求的发送者和接收者进行解耦。**
由于链中每个接收者都包含对另一个接收者的引用，如果一个对象无法处理该请求，该请求可通过链传达给下一个接收者。
## 观察者模式
**当一个对象的状态发生改变时，其所有依赖者都会收到通知并自动更新**
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新，需要在抽象类中有一个ArrayList存放观察者。
**观察者模式包含以下几个核心角色：**
> 主题（Subject）：也称为被观察者或可观察者，它是具有状态的对象，并维护着一个观察者列表。主题提供了添加、删除和通知观察者的方法。
> 观察者（Observer）：观察者是接收主题通知的对象。观察者需要实现一个更新方法，当收到主题的通知时，调用该方法进行更新操作。
> 具体主题（Concrete Subject）：具体主题是主题的具体实现类。它维护着观察者列表，并在状态发生改变时通知观察者。
> 具体观察者（Concrete Observer）：具体观察者是观察者的具体实现类。它实现了更新方法，定义了在收到主题通知时需要执行的具体操作。

